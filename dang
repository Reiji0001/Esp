import os
import time
import requests
import asyncio
import random
from time import sleep
import colorama
from colorama import Fore, Style
from pystyle import Colors, Colorate

colorama.init(autoreset=True)

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def get_channel_info(token, channel_id):
    try:
        headers = {'Authorization': token}
        response = requests.get(
            f'https://discord.com/api/v10/channels/{channel_id}',
            headers=headers
        )
        if response.status_code == 200:
            channel_data = response.json()
            guild_id = channel_data.get('guild_id')
            channel_name = channel_data.get('name', 'K√™nh kh√¥ng x√°c ƒë·ªãnh')
            
            guild_response = requests.get(
                f'https://discord.com/api/v10/guilds/{guild_id}',
                headers=headers
            )
            if guild_response.status_code == 200:
                guild_data = guild_response.json()
                return channel_name, guild_data.get('name', 'Server kh√¥ng x√°c ƒë·ªãnh')
        return 'K√™nh kh√¥ng x√°c ƒë·ªãnh', 'Server kh√¥ng x√°c ƒë·ªãnh'
    except:
        return 'K√™nh kh√¥ng x√°c ƒë·ªãnh', 'Server kh√¥ng x√°c ƒë·ªãnh'

async def spam_message(token, channel_id, messages, delay, tags):
    headers = {
        "Authorization": token,
        "Content-Type": "application/json"
    }
    # D√πng v9 ƒë·ªÉ tr√°nh m·ªôt s·ªë restriction m·ªõi ·ªü v10 v·ªõi user token
    url = f"https://discord.com/api/v9/channels/{channel_id}/messages"
    
    channel_name, server_name = get_channel_info(token, channel_id)

    while True:
        try:
            # Ch·ªçn tin nh·∫Øn NG·∫™U NHI√äN thay v√¨ l·∫ßn l∆∞·ª£t
            message = random.choice(messages)
            
            if tags:
                mentions = " ".join([f"<@{tag.strip()}>" for tag in tags])
                message = f"# {message} {mentions}"

            payload = {"content": message}
            response = requests.post(url, json=payload, headers=headers)

            if response.status_code == 200:
                print(Colorate.Horizontal(Colors.green_to_white, f"[BEN] G·ª≠i tin nh·∫Øn t·ªõi k√™nh {channel_name}: {message}"))
            elif response.status_code == 429:
                retry_after = response.json().get("retry_after", 1) + 0.2  # Th√™m buffer nh·ªè ƒë·ªÉ an to√†n
                print(Colorate.Horizontal(Colors.red_to_white, f"[RATE LIMIT] T·∫°m d·ª´ng {retry_after:.2f} gi√¢y do rate limit."))
                await asyncio.sleep(retry_after)
            else:
                print(Colorate.Horizontal(Colors.red_to_white, f"[ERROR] L·ªói {response.status_code}: {response.text}"))

        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_white, f"[EXCEPTION] {str(e)}"))
        
        # Delay gi·ªØa c√°c l·∫ßn g·ª≠i c·ªßa c√πng m·ªôt token
        await asyncio.sleep(delay)

async def main():
    clear()
    print(Colorate.Horizontal(Colors.blue_to_cyan, "=== DISCORD SPAMMER (RANDOM & NHANH H∆†N) ===\n"))
    
    print(Colorate.Horizontal(Colors.blue_to_cyan, "Nh·∫≠p ID k√™nh (c√°ch nhau b·ªüi d·∫•u ph·∫©y n·∫øu nhi·ªÅu k√™nh):"))
    channel_ids = input(Colorate.Horizontal(Colors.blue_to_cyan, "ID k√™nh: ")).split(',')
    channel_ids = [channel_id.strip() for channel_id in channel_ids]

    tokens_map = {}
    for channel_id in channel_ids:
        print(Colorate.Horizontal(Colors.blue_to_purple, f"\nCho k√™nh {channel_id}:"))
        print(Colorate.Horizontal(Colors.blue_to_purple, "Nh·∫≠p t√™n file ch·ª©a token (v√≠ d·ª•: tokens.txt):"))
        token_file = input(Colorate.Horizontal(Colors.blue_to_purple, "T√™n file token: ")).strip()

        if not os.path.exists(token_file):
            print(Colorate.Horizontal(Colors.red_to_white, f"File {token_file} kh√¥ng t·ªìn t·∫°i!"))
            return

        with open(token_file, 'r', encoding='utf-8') as file:
            tokens = [line.strip() for line in file.readlines() if line.strip()]

        if not tokens:
            print(Colorate.Horizontal(Colors.red_to_white, f"File {token_file} kh√¥ng ch·ª©a token n√†o!"))
            return

        tokens_map[channel_id] = tokens

    # Li·ªát k√™ c√°c file .txt trong th∆∞ m·ª•c hi·ªán t·∫°i
    txt_files = [f for f in os.listdir() if f.endswith('.txt') and f not in tokens_map.values()]
    if not txt_files:
        print(Colorate.Horizontal(Colors.red_to_white, "Kh√¥ng t√¨m th·∫•y file .txt n√†o ch·ª©a tin nh·∫Øn trong th∆∞ m·ª•c!"))
        return

    print(Colorate.Horizontal(Colors.yellow_to_green, "\nC√°c file .txt ch·ª©a tin nh·∫Øn c√≥ s·∫µn:"))
    for idx, file_name in enumerate(txt_files):
        print(Colorate.Horizontal(Colors.yellow_to_green, f"{idx + 1}. {file_name}"))

    try:
        file_index = int(input(Colorate.Horizontal(Colors.yellow_to_green, "Ch·ªçn file ch·ª©a tin nh·∫Øn (nh·∫≠p s·ªë th·ª© t·ª±): "))) - 1
        if file_index < 0 or file_index >= len(txt_files):
            print(Colorate.Horizontal(Colors.red_to_white, "S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá!"))
            return
    except ValueError:
        print(Colorate.Horizontal(Colors.red_to_white, "Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá!"))
        return

    file_path = txt_files[file_index]
    with open(file_path, 'r', encoding='utf-8') as file:
        messages = [line.strip() for line in file.readlines() if line.strip()]

    if not messages:
        print(Colorate.Horizontal(Colors.red_to_white, "File tin nh·∫Øn r·ªóng!"))
        return

    # Tag ng∆∞·ªùi d√πng (t√πy ch·ªçn)
    tag_choice = input(Colorate.Horizontal(Colors.yellow_to_green, "\nB·∫°n c√≥ mu·ªën tag ng∆∞·ªùi d√πng kh√¥ng? (y/n): ")).strip().lower()
    tags = []
    if tag_choice == 'y':
        tag_input = input(Colorate.Horizontal(Colors.yellow_to_green, "Nh·∫≠p ID ng∆∞·ªùi d√πng c·∫ßn tag (c√°ch nhau b·ªüi d·∫•u ph·∫©y): "))
        tags = [tag.strip() for tag in tag_input.split(',') if tag.strip()]

    # Thu th·∫≠p delay cho t·ª´ng token
    tasks = []
    total_tokens = 0
    for channel_id, tokens in tokens_map.items():
        channel_name, server_name = get_channel_info(tokens[0], channel_id)  # L·∫•y t√™n k√™nh t·ª´ token ƒë·∫ßu
        print(Colorate.Horizontal(Colors.cyan_to_blue, f"\n=== K√™nh: {channel_name} | Server: {server_name} ==="))
        
        for i, token in enumerate(tokens):
            try:
                delay_input = input(Colorate.Horizontal(Colors.yellow_to_green, 
                    f"Delay (gi√¢y) cho token {i + 1}/{len(tokens)} (khuy·∫øn ngh·ªã 0.8-2.0 ƒë·ªÉ tr√°nh ban): "))
                delay = float(delay_input)
                if delay < 0.5:
                    print(Colorate.Horizontal(Colors.red_to_white, "   Delay qu√° th·∫•p c√≥ th·ªÉ g√¢y rate limit nhanh!"))
                tasks.append(spam_message(token, channel_id, messages, delay, tags))
                total_tokens += 1
            except ValueError:
                print(Colorate.Horizontal(Colors.red_to_white, "Delay ph·∫£i l√† s·ªë! D·ª´ng ch∆∞∆°ng tr√¨nh."))
                return

    clear()
    print(Colorate.Horizontal(Colors.green_to_cyan, f"üöÄ B·∫ÆT ƒê·∫¶U SPAM V·ªöI {total_tokens} TOKEN üöÄ"))
    print(Colorate.Horizontal(Colors.green_to_cyan, "Tin nh·∫Øn s·∫Ω ƒë∆∞·ª£c g·ª≠i NG·∫™U NHI√äN v√† NHANH h∆°n!\n"))
    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())
