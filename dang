import os
import requests
import asyncio
import random
import colorama
from colorama import Fore, Style
from pystyle import Colors, Colorate

colorama.init(autoreset=True)

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def get_channel_info(token, channel_id):
    try:
        headers = {'Authorization': token}
        response = requests.get(f'https://discord.com/api/v10/channels/{channel_id}', headers=headers)
        if response.status_code == 200:
            data = response.json()
            guild_id = data.get('guild_id')
            channel_name = data.get('name', 'Unknown Channel')
            if guild_id:
                guild_resp = requests.get(f'https://discord.com/api/v10/guilds/{guild_id}', headers=headers)
                if guild_resp.status_code == 200:
                    return channel_name, guild_resp.json().get('name', 'Unknown Server')
            return channel_name, 'Unknown Server'
        return 'Unknown Channel', 'Unknown Server'
    except:
        return 'Unknown Channel', 'Unknown Server'

async def spam_message(token, channel_id, messages, base_delay, random_range, tags):
    headers = {
        "Authorization": token,
        "Content-Type": "application/json"
    }
    url = f"https://discord.com/api/v9/channels/{channel_id}/messages"  # v9 ·ªïn ƒë·ªãnh h∆°n v·ªõi user token
    
    channel_name, server_name = get_channel_info(token, channel_id)

    while True:
        try:
            message = random.choice(messages)
            
            if tags:
                mentions = " ".join([f"<@{tag.strip()}>" for tag in tags])
                message = f"# {message} {mentions}"

            payload = {"content": message}
            r = requests.post(url, json=payload, headers=headers)

            if r.status_code == 200:
                print(Colorate.Horizontal(Colors.green_to_white, f"[+] {channel_name} | {message[:50]}{'...' if len(message)>50 else ''}"))
            elif r.status_code == 429:
                retry_after = r.json().get("retry_after", 1) + 0.3
                print(Colorate.Horizontal(Colors.red_to_white, f"[RATE LIMIT] Token b·ªã limit {retry_after:.1f}s"))
                await asyncio.sleep(retry_after)
                continue
            else:
                # N·∫øu token die (401) ho·∫∑c l·ªói kh√°c ‚Üí b·ªè qua kh√¥ng spam n·ªØa
                if r.status_code == 401:
                    print(Colorate.Horizontal(Colors.red_to_white, f"[INVALID] Token h·∫øt h·∫°n ho·∫∑c b·ªã ban"))
                    break
                # C√°c l·ªói kh√°c in ra nh∆∞ng ti·∫øp t·ª•c
                # print(Colorate.Horizontal(Colors.red_to_white, f"[ERROR {r.status_code}]"))

            # Random delay ƒë·ªÉ tr√°nh pattern ƒë·ªÅu
            actual_delay = base_delay + random.uniform(-random_range, random_range)
            await asyncio.sleep(max(0.1, actual_delay))  # √≠t nh·∫•t 0.1s

        except Exception as e:
            print(Colorate.Horizontal(Colors.red_to_white, f"[EXCEPTION] {e}"))
            await asyncio.sleep(2)

async def main():
    clear()
    print(Colorate.Horizontal(Colors.blue_to_cyan, "=== DISCORD SPAMMER SI√äU NHANH - MULTI TOKEN ===\n"))

    # Nh·∫≠p channel IDs
    channel_input = input(Colorate.Horizontal(Colors.cyan_to_blue, "Nh·∫≠p ID k√™nh (c√°ch nhau b·∫±ng d·∫•u ph·∫©y): ")).strip()
    channel_ids = [cid.strip() for cid in channel_input.split(',') if cid.strip()]

    if not channel_ids:
        print(Colorate.Horizontal(Colors.red_to_white, "Kh√¥ng c√≥ k√™nh n√†o ƒë∆∞·ª£c nh·∫≠p!"))
        return

    tokens_map = {}
    total_tokens = 0

    # Nh·∫≠p token file cho t·ª´ng k√™nh
    for channel_id in channel_ids:
        print(f"\n--- K√™nh ID: {channel_id} ---")
        token_file = input(Colorate.Horizontal(Colors.blue_to_purple, "T√™n file token (v√≠ d·ª•: tokens1.txt): ")).strip()
        
        if not os.path.exists(token_file):
            print(Colorate.Horizontal(Colors.red_to_white, f"File {token_file} kh√¥ng t·ªìn t·∫°i! B·ªè qua k√™nh n√†y."))
            continue
        
        with open(token_file, 'r', encoding='utf-8') as f:
            tokens = [line.strip() for line in f if line.strip()]
        
        if not tokens:
            print(Colorate.Horizontal(Colors.red_to_white, "File token r·ªóng! B·ªè qua k√™nh."))
            continue
        
        tokens_map[channel_id] = tokens
        total_tokens += len(tokens)
        print(Colorate.Horizontal(Colors.green_to_white, f"ƒê√£ load {len(tokens)} token cho k√™nh {channel_id}"))

    if total_tokens == 0:
        print(Colorate.Horizontal(Colors.red_to_white, "Kh√¥ng c√≥ token h·ª£p l·ªá n√†o!"))
        return

    # Ch·ªçn file tin nh·∫Øn
    txt_files = [f for f in os.listdir('.') if f.endswith('.txt') and f.lower() not in [tf.lower() for tf_list in tokens_map.values() for tf in tf_list]]
    txt_files = list(set(txt_files))  # tr√°nh tr√πng

    if not txt_files:
        print(Colorate.Horizontal(Colors.red_to_white, "Kh√¥ng t√¨m th·∫•y file tin nh·∫Øn .txt n√†o!"))
        return

    print("\nFile tin nh·∫Øn c√≥ s·∫µn:")
    for i, f in enumerate(txt_files):
        print(Colorate.Horizontal(Colors.yellow_to_green, f"{i+1}. {f}"))
    
    try:
        choice = int(input(Colorate.Horizontal(Colors.yellow_to_green, "Ch·ªçn file tin nh·∫Øn (s·ªë): "))) - 1
        msg_file = txt_files[choice]
    except:
        print(Colorate.Horizontal(Colors.red_to_white, "L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!"))
        return

    with open(msg_file, 'r', encoding='utf-8') as f:
        messages = [line.strip() for line in f if line.strip()]

    if not messages:
        print(Colorate.Horizontal(Colors.red_to_white, "File tin nh·∫Øn r·ªóng!"))
        return

    # Tag (t√πy ch·ªçn)
    tags = []
    if input(Colorate.Horizontal(Colors.yellow_to_green, "\nC√≥ tag ng∆∞·ªùi d√πng kh√¥ng? (y/n): ")).strip().lower() == 'y':
        tag_input = input(Colorate.Horizontal(Colors.yellow_to_green, "Nh·∫≠p ID tag (c√°ch nhau ph·∫©y): "))
        tags = [t.strip() for t in tag_input.split(',') if t.strip()]

    # Delay chung (ho·∫∑c ri√™ng theo k√™nh)
    delay_mode = input(Colorate.Horizontal(Colors.cyan_to_blue, "\nDelay: (1) Chung cho t·∫•t c·∫£ | (2) Ri√™ng t·ª´ng k√™nh [1/2]: ")).strip() or "1"

    tasks = []

    if delay_mode == "2":
        for channel_id, tokens in tokens_map.items():
            channel_name, server_name = get_channel_info(tokens[0], channel_id)
            print(f"\n--- Delay cho k√™nh {channel_name} ({server_name}) ---")
            try:
                base_delay = float(input(Colorate.Horizontal(Colors.yellow_to_green, "Delay c∆° b·∫£n (gi√¢y, v√≠ d·ª• 1.0): ")))
                rand_range = float(input(Colorate.Horizontal(Colors.yellow_to_green, "Random ¬± (gi√¢y, v√≠ d·ª• 0.4): ")))
            except:
                print("Input sai, d√πng m·∫∑c ƒë·ªãnh 1.0 ¬± 0.3")
                base_delay, rand_range = 1.0, 0.3

            for token in tokens:
                tasks.append(spam_message(token, channel_id, messages, base_delay, rand_range, tags))
    else:
        # Delay chung cho t·∫•t c·∫£
        try:
            base_delay = float(input(Colorate.Horizontal(Colors.yellow_to_green, "\nDelay c∆° b·∫£n cho t·∫•t c·∫£ token (gi√¢y, khuy·∫øn ngh·ªã 0.8-1.5): ")))
            rand_range = float(input(Colorate.Horizontal(Colors.yellow_to_green, "Random ¬± (gi√¢y, khuy·∫øn ngh·ªã 0.3-0.5): ")))
        except:
            base_delay, rand_range = 1.0, 0.4

        for channel_id, tokens in tokens_map.items():
            for token in tokens:
                tasks.append(spam_message(token, channel_id, messages, base_delay, rand_range, tags))

    # B·∫Øt ƒë·∫ßu spam
    clear()
    print(Colorate.Horizontal(Colors.green_to_cyan, f"üöÄ B·∫ÆT ƒê·∫¶U SPAM V·ªöI {total_tokens} TOKEN üöÄ"))
    print(Colorate.Horizontal(Colors.green_to_cyan, f"Delay: {base_delay} ¬± {rand_range}s | Tin nh·∫Øn: NG·∫™U NHI√äN\n"))

    await asyncio.gather(*tasks)

if __name__ == "__main__":
    asyncio.run(main())
